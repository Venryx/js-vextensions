"use strict";
//export class Element_EmptyImpl implements Element {}
/*export const Element_EmptyImpl = null as new()=>Element;

class ArrayConstructor_Helper<T> extends Array<T> {}
export const Array_EmptyImpl = null as typeof ArrayConstructor_Helper;*/
/*export class Array_EmptyImpl<T> implements Array<T> {
    [n: number]: T;
    length: number;
    toString(): string { throw 0; }
    toLocaleString(): string { throw 0; }
    pop(): T {}
    push(...items: T[]): number { throw 0; }
    concat(...items: ConcatArray<T>[]): T[];
    concat(...items: (T | ConcatArray<T>)[]): T[];
    concat(...items?: any[]) {}
    reverse(): T[] {}
    shift(): T {}
    slice(start?: number, end?: number): T[] { throw 0; }
    sort(compareFn?: (a: T, b: T) => number): this { throw 0; }
    splice(start: number, deleteCount?: number): T[];
    splice(start: number, deleteCount: number, ...items: T[]): T[];
    splice(start: any, deleteCount?: any, ...rest?: any[]) {}
    unshift(...items: T[]): number { throw 0; }
    indexOf(searchElement: T, fromIndex?: number): number { throw 0; }
    lastIndexOf(searchElement: T, fromIndex?: number): number { throw 0; }
    every(callbackfn: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean { throw 0; }
    some(callbackfn: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean { throw 0; }
    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void {}
    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[] { throw 0; }
    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];
    filter(callbackfn: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[];
    filter(callbackfn: any, thisArg?: any) {}
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
    reduce(callbackfn: any, initialValue?: any) {}
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
    reduceRight(callbackfn: any, initialValue?: any) {}
    find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S;
    find(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): T;
    find(predicate: any, thisArg?: any) {}
    findIndex(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): number { throw 0; }
    fill(value: T, start?: number, end?: number): this { throw 0; }
    copyWithin(target: number, start: number, end?: number): this { throw 0; }
    [Symbol.iterator](): IterableIterator<T> { throw 0; }
    entries(): IterableIterator<[number, T]> { throw 0; }
    keys(): IterableIterator<number> { throw 0; }
    values(): IterableIterator<T> { throw 0; }
    [Symbol.unscopables](): {copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean;} { throw 0; }
    includes(searchElement: T, fromIndex?: number): boolean { throw 0; }
}*/ 
//# sourceMappingURL=EmptyImplementations.js.map