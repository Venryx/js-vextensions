export interface ForEachExtras {
    index: number;
    Break: () => void;
    Continue: () => void;
}
export declare type ItemTFor<T> = T extends Array<infer ItemT> ? ItemT : T extends ArrayCEClass<infer ItemT> ? ItemT : T;
export declare type ArrayLike<T> = Array<T> | ArrayCEClass<T>;
export declare class ArrayCEClass<ItemT> {
    ForEach<T>(this: ArrayLike<T>, func: (value: T, extras: ForEachExtras) => any): void;
    ForEachAsync<T>(this: ArrayLike<T>, func: (value: T, extras: ForEachExtras) => any): Promise<void>;
    Contains<T>(this: ArrayLike<T>, item: T): boolean;
    ContainsAny<T>(this: ArrayLike<T>, ...items: T[]): boolean;
    Prepend<T>(this: ArrayLike<T>, ...newItems: T[]): void;
    Add<T>(this: ArrayLike<T>, item: T): number;
    CAdd<T>(this: ArrayLike<T>, item: T): T[];
    TAdd<T>(this: ArrayLike<T>, item: T): T;
    AddRange<T>(this: ArrayLike<T>, array: T[]): ArrayLike<T>;
    Remove<T>(this: ArrayLike<T>, item: T): boolean;
    RemoveAll<T>(this: ArrayLike<T>, items: T[]): void;
    RemoveAt<T>(this: ArrayLike<T>, index: number): T;
    Insert<T>(this: ArrayLike<T>, index: number, obj: T): void;
    SetItems<T>(this: ArrayLike<T>, items: T[]): T[];
    Reversed<T>(this: ArrayLike<T>): T[];
    Any<T>(this: ArrayLike<T>, matchFunc: (item: T, index?: number) => boolean): boolean;
    All<T>(this: ArrayLike<T>, matchFunc: (item: T, index?: number) => boolean): boolean;
    Where<T>(this: ArrayLike<T>, matchFunc: (item: T, index?: number) => boolean): T[];
    Select<T, T2>(this: ArrayLike<T>, selectFunc: (item: T, index?: number) => T2): T2[];
    SelectMany<T, T2>(this: ArrayLike<T>, selectFunc: (item: T, index?: number) => T2[]): T2[];
    Count<T>(this: ArrayLike<T>): number;
    VCount<T>(this: ArrayLike<T>, matchFunc: (item: T) => boolean): any;
    Clear<T>(this: ArrayLike<T>): void;
    First<T>(this: ArrayLike<T>, matchFunc?: (item: T) => boolean): any;
    FirstOrX<T>(this: ArrayLike<T>, matchFunc?: (item: T) => boolean, x?: any): any;
    FirstWith<T>(this: ArrayLike<T>, propName: string, propValue: any): any;
    Last<T>(this: ArrayLike<T>, matchFunc?: any): any;
    LastOrX<T>(this: ArrayLike<T>, matchFunc?: (item: T) => boolean, x?: any): any;
    XFromLast<T>(this: ArrayLike<T>, x: number): T;
    Move<T>(this: ArrayLike<T>, item: T, newIndex: number, newIndexAsPreRemovalIndexVSFinalIndex?: boolean): number;
    ToMap<T, Value>(this: ArrayLike<T>, keyFunc: (item: T, index: number) => string, valFunc: (item: T, index: number) => Value): {
        [key: string]: Value;
    };
    Skip<T>(this: ArrayLike<T>, count: number): any[];
    Take<T>(this: ArrayLike<T>, count: number): any[];
    TakeLast<T>(this: ArrayLike<T>, count: number): any[];
    FindIndex<T>(this: ArrayLike<T>, matchFunc: (item: T) => boolean): number;
    OrderBy<T>(this: ArrayLike<T>, valFunc?: (item: any, index: number) => any): T[];
    OrderByDescending<T>(this: ArrayLike<T>, valFunc?: (item: any, index: number) => any): any;
    Distinct<T>(this: ArrayLike<T>): any[];
    Except<T>(this: ArrayLike<T>, ...args: any[]): any;
    IfEmptyThen<T>(this: ArrayLike<T>, valIfSelfIsEmpty: any): any;
    Min<T>(this: ArrayLike<T>, valFunc?: (item: T) => number, asNumbers?: boolean): any;
    Max<T>(this: ArrayLike<T>, valFunc?: (item: T) => number, asNumbers?: boolean): any;
    Sum<T extends number>(this: ArrayLike<T>): number;
    Average<T extends number>(this: ArrayLike<T>): any;
    Median<T extends number>(this: ArrayLike<T>): any;
    Random<T>(this: ArrayLike<T>): any;
    oldJoin: (separator?: string) => string;
    join<T>(this: ArrayLike<T>, separator?: string): string;
}
export declare const ArrayCE: <T>(nextThis: T[]) => ArrayCEClass<T>;
export declare const ArrayCES: {
    ForEach: (thisArg: Object, func: (value: unknown, extras: ForEachExtras) => any) => void;
    ForEachAsync: (thisArg: Object, func: (value: unknown, extras: ForEachExtras) => any) => Promise<void>;
    Contains: (thisArg: Object, item: unknown) => boolean;
    ContainsAny: (thisArg: Object, ...args: unknown[]) => boolean;
    Prepend: (thisArg: Object, ...args: unknown[]) => void;
    Add: (thisArg: Object, item: unknown) => number;
    CAdd: (thisArg: Object, item: unknown) => unknown[];
    TAdd: (thisArg: Object, item: unknown) => unknown;
    AddRange: (thisArg: Object, array: unknown[]) => ArrayLike<unknown>;
    Remove: (thisArg: Object, item: unknown) => boolean;
    RemoveAll: (thisArg: Object, items: unknown[]) => void;
    RemoveAt: (thisArg: Object, index: number) => unknown;
    Insert: (thisArg: Object, index: number, obj: unknown) => void;
    SetItems: (thisArg: Object, items: unknown[]) => unknown[];
    Reversed: (thisArg: Object) => unknown[];
    Any: (thisArg: Object, matchFunc: (item: unknown, index?: number) => boolean) => boolean;
    All: (thisArg: Object, matchFunc: (item: unknown, index?: number) => boolean) => boolean;
    Where: (thisArg: Object, matchFunc: (item: unknown, index?: number) => boolean) => unknown[];
    Select: (thisArg: Object, selectFunc: (item: unknown, index?: number) => unknown) => unknown[];
    SelectMany: (thisArg: Object, selectFunc: (item: unknown, index?: number) => unknown[]) => unknown[];
    Count: (thisArg: Object) => number;
    VCount: (thisArg: Object, matchFunc: (item: unknown) => boolean) => any;
    Clear: (thisArg: Object) => void;
    First: (thisArg: Object, matchFunc?: (item: unknown) => boolean) => any;
    FirstOrX: (thisArg: Object, matchFunc?: (item: unknown) => boolean, x?: any) => any;
    FirstWith: (thisArg: Object, propName: string, propValue: any) => any;
    Last: (thisArg: Object, matchFunc?: any) => any;
    LastOrX: (thisArg: Object, matchFunc?: (item: unknown) => boolean, x?: any) => any;
    XFromLast: (thisArg: Object, x: number) => unknown;
    Move: (thisArg: Object, item: unknown, newIndex: number, newIndexAsPreRemovalIndexVSFinalIndex?: boolean) => number;
    ToMap: (thisArg: Object, keyFunc: (item: unknown, index: number) => string, valFunc: (item: unknown, index: number) => unknown) => {
        [key: string]: unknown;
    };
    Skip: (thisArg: Object, count: number) => any[];
    Take: (thisArg: Object, count: number) => any[];
    TakeLast: (thisArg: Object, count: number) => any[];
    FindIndex: (thisArg: Object, matchFunc: (item: unknown) => boolean) => number;
    OrderBy: (thisArg: Object, valFunc?: (item: any, index: number) => any) => unknown[];
    OrderByDescending: (thisArg: Object, valFunc?: (item: any, index: number) => any) => any;
    Distinct: (thisArg: Object) => any[];
    Except: (thisArg: Object, ...args: any[]) => any;
    IfEmptyThen: (thisArg: Object, valIfSelfIsEmpty: any) => any;
    Min: (thisArg: Object, valFunc?: (item: unknown) => number, asNumbers?: boolean) => any;
    Max: (thisArg: Object, valFunc?: (item: unknown) => number, asNumbers?: boolean) => any;
    Sum: (thisArg: Object) => number;
    Average: (thisArg: Object) => any;
    Median: (thisArg: Object) => any;
    Random: (thisArg: Object) => any;
    oldJoin: (thisArg: Object, separator?: string) => string;
    join: (thisArg: Object, separator?: string) => string;
};
